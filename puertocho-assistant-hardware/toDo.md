# PuertoCho Assistant Hardware - Hitos del Proyecto

## üìã Resumen del Proyecto

El servicio `puertocho-assistant-hardware` es responsable de manejar todo el hardware de la Raspberry Pi, incluyendo:
- **Grabaci√≥n de audio** con el m√≥dulo ReSpeaker 2-Mic Pi HAT V1.0
- **Control de LEDs RGB** APA102 para indicar estados del asistente
- **Detecci√≥n de bot√≥n** en GPIO17 para activaci√≥n manual
- **M√≥dulo NFC** por I2C para lectura/escritura de etiquetas
- **Wake word detection** con Porcupine
- **Detecci√≥n de silencio** para parar grabaci√≥n autom√°ticamente
- **Comunicaci√≥n HTTP/WebSocket** con el backend

## üèõÔ∏è Arquitectura del Sistema

Para asegurar la mantenibilidad y escalabilidad del proyecto, se ha decidido adoptar una arquitectura basada en una **M√°quina de Estados Centralizada (`StateManager`)**.

- **`StateManager`**: Orquesta el flujo de la aplicaci√≥n. Gestiona los estados (`IDLE`, `LISTENING`, `PROCESSING`, etc.) y coordina las acciones entre los diferentes m√≥dulos de hardware.
- **`AudioManager`**: Provee un flujo de audio constante. No conoce el estado de la aplicaci√≥n, simplemente emite los datos del micr√≥fono.
- **M√≥dulos de Hardware (`ButtonHandler`, `WakeWordDetector`, `VADHandler`, `LEDController`)**: Act√∫an como componentes desacoplados.
    - Notifican eventos al `StateManager` (ej: "bot√≥n presionado", "wake word detectado").
    - Reciben comandos del `StateManager` (ej: "cambiar patr√≥n de LED").

Esta arquitectura promueve el bajo acoplamiento y la alta cohesi√≥n, facilitando las pruebas y futuras modificaciones. La implementaci√≥n de los hitos se realizar√° siguiendo este patr√≥n.

## üéØ Hitos del Proyecto

### Hito 1: Configuraci√≥n Base del Contenedor
- [x] **1.1** Configurar `Dockerfile` con imagen base Python 3.9+ para ARM64
- [x] **1.2** Instalar dependencias del sistema (audio, I2C, GPIO)
- [x] **1.3** Configurar privilegios y acceso a hardware (privileged: true)
- [x] **1.4** Configurar variables de entorno en archivo `.env`
- [x] **1.5** Crear estructura de directorios del proyecto
- [x] **1.6** Configurar logging y manejo de errores b√°sico

### Hito 2: Configuraci√≥n de Audio y ReSpeaker
- [x] **2.1** Configurar driver del ReSpeaker 2-Mic Pi HAT V1.0
- [x] **2.2** Implementar detecci√≥n autom√°tica de dispositivos de audio
- [x] **2.2.1** Ejecutar script para verificar la detecci√≥n de audio
- [x] **2.3** Crear clase `AudioManager` para grabaci√≥n/reproducci√≥n
- [x] **2.4** Implementar configuraci√≥n de audio (sample rate, channels, formato)
- [x] **2.5** A√±adir pruebas de audio para verificar funcionamiento
  - [x] **2.5.1** Tests unitarios completos (`test_audio.py`)
  - [x] **2.5.2** Script interactivo (`test_audio_manager.py`)
  - [x] **2.5.3** Guardado de audio en archivos WAV
  - [x] **2.5.4** Reproducci√≥n de audio guardado

### Hito 3: Control de LEDs RGB (APA102)
- [x] **3.1** Implementar clase `LEDController` para manejar LEDs APA102
- [x] **3.2** Configurar comunicaci√≥n SPI para LEDs RGB
- [x] **3.3** Crear patrones de LED para diferentes estados:
  - Disponible (azul pulsante)
  - Escuchando (verde s√≥lido)
  - Procesando (amarillo giratorio)
  - Error (rojo parpadeante)
- [x] **3.4** Implementar transiciones suaves entre estados
- [x] **3.5** A√±adir control de brillo adaptativo
- [x] **3.6** Crear scripts de prueba para cada patr√≥n

### Hito 4: Detecci√≥n de Bot√≥n y GPIO
- [x] **4.1** Implementar clase `ButtonHandler` para GPIO17
- [x] **4.2** Configurar interrupciones para detecci√≥n de pulsaciones
- [x] **4.3** Implementar debouncing para evitar falsas activaciones
- [x] **4.4** Manejar pulsaci√≥n corta y larga
- [x] **4.5** Notificar al StateManager los eventos de bot√≥n (corta/larga) a trav√©s de un callback
- [x] **4.6** Integrar con el `StateManager` para iniciar/detener la escucha manualmente
- [x] **4.7** Implementar modo simulaci√≥n para testing sin hardware
- [x] **4.8** Crear script de pruebas completo (`test_button_handler.py`)
- [x] **4.9** Configurar permisos GPIO en contenedor Docker
- [x] **4.10** Validar funcionamiento en hardware real

### Hito 5: Wake Word Detection (Porcupine)
- [x] **5.1** Configurar Porcupine con modelo personalizado "Puerto-ocho"
- [x] **5.2** Implementar clase `WakeWordDetector` que procesa chunks de audio
- [x] **5.2.1** Implementar buffer circular para audio en tiempo real
- [x] **5.3** Optimizar sensibilidad para entorno dom√©stico
- [x] **5.4** Implementar filtros de audio para mejorar detecci√≥n
- [x] **5.5** A√±adir logging de eventos de wake word
- [x] **5.6** Crear modo de calibraci√≥n para ajustar sensibilidad
- [x] **5.7** Integrar con `StateManager`: recibir√° audio en estado `IDLE` y notificar√° detecciones

### Hito 6: Detecci√≥n de Silencio (VAD)
- [ ] **6.1** Implementar Voice Activity Detection con WebRTC VAD
- [ ] **6.2** Configurar umbrales de silencio din√°micos
- [ ] **6.3** Notificar al `StateManager` el inicio y fin del habla para controlar la grabaci√≥n
- [ ] **6.4** A√±adir filtros de ruido de fondo
- [ ] **6.5** Optimizar para diferentes niveles de ruido ambiental
- [ ] **6.6** Crear sistema de calibraci√≥n autom√°tica
- [ ] **6.7** Integrar con `StateManager`: recibir√° audio en estado `LISTENING`

### Hito 7: M√≥dulo NFC (I2C)
- [ ] **7.1** Configurar comunicaci√≥n I2C para m√≥dulo NFC
- [ ] **7.2** Implementar clase `NFCManager` para operaciones b√°sicas
- [ ] **7.3** Funcionalidades de lectura:
  - Detectar presencia de etiqueta
  - Leer UID de etiqueta
  - Leer datos NDEF
- [ ] **7.4** Funcionalidades de escritura:
  - Escribir datos NDEF
  - Formatear etiquetas
  - Proteger etiquetas
- [ ] **7.5** Implementar sistema de acciones programables
- [ ] **7.6** Crear interfaz para configurar acciones NFC

### Hito 8: Sistema de Estados del Asistente (StateManager)
- [ ] **8.1** Implementar la clase `StateManager` en `app/core/state_manager.py`.
- [ ] **8.2** Definir los estados principales como un Enum: `IDLE`, `LISTENING`, `PROCESSING`, `SPEAKING`, `ERROR`.
- [ ] **8.3** Implementar el m√©todo `handle_audio_chunk` que distribuir√° el audio al componente correspondiente seg√∫n el estado actual (`WakeWordDetector` o `VADHandler`).
- [ ] **8.4** Crear la l√≥gica de transiciones entre estados (ej: `IDLE` -> `LISTENING` al detectar wake word o bot√≥n).
- [ ] **8.5** Integrar `LEDController` para que los patrones de LED se sincronicen autom√°ticamente con los cambios de estado.
- [ ] **8.6** Implementar un sistema de callbacks o eventos para que los manejadores de hardware notifiquen al `StateManager`.
- [ ] **8.7** A√±adir logging detallado para cada transici√≥n de estado y evento recibido.
- [ ] **8.8** Manejar timeouts y recuperaci√≥n de errores b√°sicos (ej: volver a `IDLE` si algo falla).

### Hito 9: API HTTP y Endpoints
- [ ] **9.1** Configurar FastAPI para endpoints HTTP
- [ ] **9.2** Implementar endpoints principales:
  - `GET /health` - Estado del servicio
  - `POST /audio/start` - Iniciar grabaci√≥n
  - `POST /audio/stop` - Parar grabaci√≥n
  - `GET /audio/status` - Estado de audio
  - `POST /nfc/read` - Leer etiqueta NFC
  - `POST /nfc/write` - Escribir etiqueta NFC
  - `GET /nfc/status` - Estado NFC
  - `POST /led/pattern` - Cambiar patr√≥n LED
- [ ] **9.3** Implementar autenticaci√≥n y validaci√≥n
- [ ] **9.4** A√±adir documentaci√≥n OpenAPI/Swagger
- [ ] **9.5** Implementar rate limiting
- [ ] **9.6** A√±adir m√©tricas y monitoreo

### Hito 10: Comunicaci√≥n WebSocket
- [ ] **10.1** Implementar cliente WebSocket para comunicaci√≥n en tiempo real
- [ ] **10.2** Eventos a enviar al backend:
  - Audio grabado
  - Cambios de estado
  - Eventos de bot√≥n
  - Eventos NFC
  - M√©tricas de hardware
- [ ] **10.3** Eventos a recibir del backend:
  - Comandos de control
  - Cambios de configuraci√≥n
  - Patrones LED personalizados
- [ ] **10.4** Implementar reconexi√≥n autom√°tica
- [ ] **10.5** A√±adir heartbeat y keep-alive
- [ ] **10.6** Manejar cola de mensajes para conexiones intermitentes

### Hito 11: Integraci√≥n con Backend
- [ ] **11.1** Adaptar endpoints del backend para recibir:
  - `/hardware/audio` - Recibir audio grabado
  - `/hardware/status` - Recibir estado del hardware
  - `/hardware/nfc` - Recibir eventos NFC
- [ ] **11.2** Implementar formato de datos est√°ndar
- [ ] **11.3** A√±adir compresi√≥n de audio para transmisi√≥n
- [ ] **11.4** Implementar retry logic para fallos de comunicaci√≥n
- [ ] **11.5** Crear sistema de configuraci√≥n remota
- [ ] **11.6** A√±adir sincronizaci√≥n de tiempo entre servicios

### Hito 12: Configuraci√≥n y Persistencia
- [ ] **12.1** Crear archivo de configuraci√≥n YAML/JSON
- [ ] **12.2** Implementar sistema de configuraci√≥n por capas:
  - Configuraci√≥n por defecto
  - Configuraci√≥n de usuario
  - Variables de entorno
- [ ] **12.3** Persistir configuraciones de calibraci√≥n
- [ ] **12.4** Implementar backup y restauraci√≥n de configuraci√≥n
- [ ] **12.5** Crear interfaz de configuraci√≥n web
- [ ] **12.6** A√±adir validaci√≥n de configuraci√≥n

### Hito 13: Monitoreo y Logging
- [ ] **13.1** Implementar logging estructurado (JSON)
- [ ] **13.2** Configurar rotaci√≥n de logs
- [ ] **13.3** A√±adir m√©tricas de rendimiento:
  - Latencia de audio
  - Uso de CPU/RAM
  - Eventos por segundo
- [ ] **13.4** Implementar health checks avanzados
- [ ] **13.5** Crear dashboard de monitoreo
- [ ] **13.6** A√±adir alertas por email/webhook

### Hito 14: Testing y Calidad
- [ ] **14.1** Crear tests unitarios para cada componente
- [ ] **14.2** Implementar tests de integraci√≥n
- [ ] **14.3** A√±adir tests de hardware simulado
- [ ] **14.4** Crear suite de tests de rendimiento
- [ ] **14.5** Implementar tests de stress
- [ ] **14.6** Configurar CI/CD para tests autom√°ticos

### Hito 15: Optimizaci√≥n y Producci√≥n
- [ ] **15.1** Optimizar uso de memoria y CPU
- [ ] **15.2** Implementar cache para operaciones frecuentes
- [ ] **15.3** A√±adir compresi√≥n y optimizaci√≥n de datos
- [ ] **15.4** Configurar monitoreo de producci√≥n
- [ ] **15.5** Implementar actualizaciones OTA
- [ ] **15.6** Crear documentaci√≥n de deployment

## üîß Tecnolog√≠as y Librer√≠as Principales

### Audio
- **sounddevice**: Grabaci√≥n y reproducci√≥n de audio
- **webrtcvad**: Voice Activity Detection
- **numpy**: Procesamiento de se√±ales de audio

### Wake Word
- **pvporcupine**: Detecci√≥n de wake word
- **Modelo personalizado**: Puerto-ocho_es_raspberry-pi_v3_0_0.ppn

### Hardware
- **RPi.GPIO**: Control de GPIO y botones
- **spidev**: Comunicaci√≥n SPI para LEDs APA102
- **I2C**: Comunicaci√≥n con m√≥dulo NFC

### Comunicaci√≥n
- **fastapi**: API HTTP
- **uvicorn**: Servidor ASGI
- **websockets**: Cliente WebSocket
- **requests**: Cliente HTTP

### Utilidades
- **python-dotenv**: Gesti√≥n de variables de entorno
- **asyncio**: Programaci√≥n as√≠ncrona
- **threading**: Manejo de hilos para hardware

## üìÅ Estructura de Archivos Propuesta

```
puertocho-assistant-hardware/
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                 # Punto de entrada principal
‚îÇ   ‚îú‚îÄ‚îÄ config.py               # Configuraci√≥n centralizada
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ audio_manager.py    # Gesti√≥n de audio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ led_controller.py   # Control de LEDs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button_handler.py   # Manejo de botones
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nfc_manager.py      # Gesti√≥n NFC
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state_machine.py    # M√°quina de estados
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wake_word_detector.py # Detecci√≥n wake word
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ http_server.py      # Servidor HTTP
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocket_client.py # Cliente WebSocket
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.py           # Logging
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics.py          # M√©tricas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ calibration.py      # Calibraci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ tests/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ test_audio.py
‚îÇ       ‚îú‚îÄ‚îÄ test_led.py
‚îÇ       ‚îú‚îÄ‚îÄ test_nfc.py
‚îÇ       ‚îî‚îÄ‚îÄ test_integration.py
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ setup.sh               # Script de instalaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ test_hardware.py       # Pruebas de hardware
‚îÇ   ‚îî‚îÄ‚îÄ calibrate.py           # Calibraci√≥n autom√°tica
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ API.md
‚îÇ   ‚îî‚îÄ‚îÄ DEPLOYMENT.md
‚îî‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ porcupine_params_es.pv
    ‚îî‚îÄ‚îÄ Puerto-ocho_es_raspberry-pi_v3_0_0.ppn
```

## üöÄ Pr√≥ximos Pasos

1. **‚úÖ Hito 1**: Configuraci√≥n base del contenedor - **COMPLETADO**
2. **‚úÖ Hito 2**: Configuraci√≥n de Audio y ReSpeaker - **COMPLETADO**
3. **‚úÖ Hito 3**: Control de LEDs RGB (APA102) - **COMPLETADO**
4. **‚úÖ Hito 4**: Detecci√≥n de Bot√≥n y GPIO - **COMPLETADO**
5. **üîÑ Pr√≥ximo**: Implementar Hito 5 (Wake Word Detection)
6. **Planificado**: Desarrollar Hitos 6-8 (VAD, NFC, StateManager)
7. **Futuro**: Integrar Hitos 9-11 (API, WebSocket, Backend)
8. **Final**: Finalizar Hitos 12-15 (Configuraci√≥n, Testing, Producci√≥n)

## üìù Notas Importantes

- ‚úÖ El contenedor debe ejecutarse con `privileged: true` para acceso al hardware
- ‚úÖ Usar `network_mode: host` para comunicaci√≥n eficiente  
- ‚úÖ Configurar correctamente I2C, SPI y GPIO en el sistema host
- ‚úÖ Permisos GPIO resueltos ejecutando contenedor como root (user: "0:0")
- ‚úÖ ButtonHandler implementado con soporte completo para hardware real y simulaci√≥n
- üîÑ Considerar latencia y rendimiento en tiempo real para pr√≥ximos m√≥dulos
- üîÑ Implementar manejo robusto de errores de hardware
- üîÑ Documentar todas las configuraciones y calibraciones

### üéØ Estado Actual del Proyecto
**Hardware Base**: ‚úÖ COMPLETADO (Hitos 1-4)
- Contenedor Docker configurado y funcionando
- Audio ReSpeaker operativo con grabaci√≥n/reproducci√≥n
- LEDs RGB APA102 con patrones din√°micos
- Detecci√≥n de bot√≥n GPIO con eventos y callbacks

**Pr√≥ximo Objetivo**: üöÄ Wake Word Detection (Hito 5)
- Integrar Porcupine para detecci√≥n "Puerto-ocho"
- Implementar buffer circular de audio
- Crear sistema de calibraci√≥n de sensibilidad